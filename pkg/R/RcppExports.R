# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @title run_gap_factor
#' @name run_gap_factor
#'
#' @description
#' Implementation of the probabilistic Count Matrix Factorization (pCMF)
#' method based on the Gamma-Poisson hirerarchical factor model. This method
#' is specifically designed to analyze count matrices such as gene expression
#' profiles (RNA-seq) obtained by high throughput sequencing.
#'
#' @details
#' Wrapper for a Cpp function.
#'
#' In the probabilistic Count Matrix Factorization framework (pCMF), the
#' count data matrix \eqn{X} (dim \eqn{n \times p}) is approximated
#' by a matrix product \eqn{U V^t} where \eqn{U_{n\times K}} and
#' \eqn{V_{p\times K}} respectively represent the individuals
#' (rows of \eqn{X}) and variables (cols of \eqn{X})
#' in a sub-space of dimension \eqn{K}.
#'
#' In the pCMF framework, the approximation between \eqn{X} and
#' \eqn{U V^t} is made regarding the Kullback-Leibler divergence, which
#' corresponds to the Bregman divergence derived from the model
#' \eqn{X \sim P(U V^t)}, i.e. each entry \eqn{X_{ij}} is assumed to follow
#' a Poisson distribution of parameter \eqn{\sum_k U_{ik} V_{jk}}.
#' In addition, factors \eqn{U_{ik}} and \eqn{V_{jk}} are assumed to
#' be independent latent random variables following Gamma distributions.
#'
#' More details regarding pCMF can be found in Durif et al. (2017).
#'
#' @references
#' Durif, G., Modolo, L., Mold, J.E., Lambert-Lacroix, S., Picard, F., 2017.
#' Probabilistic Count Matrix Factorization for Single Cell Expression Data
#' Analysis. arXiv:1710.11028 [stat].
#'
#' @author
#' Ghislain Durif, \email{gd.dev@libertymail.net}
#'
#' @param X a count data matrix of dimension \code{n x p}.
#' @param K integer, required dimension of the subspace for the latent
#' representation.
#' @param U matrix of dimension \code{n x K}, initial values for the factor
#' matrix \code{U}. It is used to intialized the variational parameter of the
#' varitional distribution over the factor \code{U}. Default is NULL and
#' variational parameters over \code{U} are intialized otherwise.
#' Note: if you supply \code{U} input parameter, you should supply
#' \code{V} input parameter.
#' @param V matrix of dimension \code{p x K}, initial values for the factor
#' matrix \code{V}. It is used to intialized the variational parameter of the
#' varitional distribution over the factor \code{V}. Default is NULL and
#' variational parameters over \code{V} are intialized otherwise.
#' Note: if you supply \code{V} input parameter, you should supply
#' \code{U} input parameter.
#' @param verbose boolean indicating verbosity. Default is True.
#' @param monitor boolean indicating if model related measures
#' (log-likelihood, deviance, Bregman divergence between \eqn{X}
#' and \eqn{UV^t}) should be computed. Default is True.
#' @param iter_max integer, maximum number of iterations after which the
#' optimization is stopped even when the algorithm did not converge.
#' Default is 1000.
#' @param iter_min integer, minimum number of iterations without checking
#' convergence. Default is 500.
#' @param init_mode string, intialization mode to choose between "random",
#' "nmf". Default value is "random". Unused if initial values are given
#' for U and V or a1, a2, b1 and b2.
#' @param epsilon double precision parameter to assess convergence, i.e.
#' the convergence is reached when the gap (absolute or normalized) between
#' two iterates becomes smaller than epsilon. Default is 1e-2.
#' @param additional_iter integer, number of successive iterations during
#' which the convergence criterion should be verified to assess convergence.
#' @param conv_mode \{0,1,2\}-valued indicator setting how to assess
#' convergence: 0 for absolute gap, 1 for normalized gap between
#' two iterates and 2 for custom criterion (depends on the considered
#' method/model). Default is 1.
#' @param ninit integer, number of initialization to consider. In multiple
#' initialization mode (>1), the algorithm is run for \code{iter_init}
#' iterations with mutliple seeds and the best one (regarding the optimization
#' criterion) is kept. Default value is 1.
#' @param iter_init integer, number of iterations during which the algorithms
#' is run in multi-initialization mode. Default value is 100.
#' @param ncores integer indicating the number of cores to use for
#' parallel computation. Default is 1 and no multi-threading is used.
#' @param reorder_factor boolean indicating if factors should be reordered
#' according to the model-related deviance criterion. Default value is True.
#' @param seed positive integer, seed value for random number generator.
#' Default is NULL and the seed is set based on the current time.
#' @param a1 matrix of dimension \code{n x K}, initial values for the
#' variational shape parameter of the Gamma variational distribution over the
#' factor \code{U}. Default is NULL and each row \code{i} in \code{a1} is
#' randomly initialized from a Gamma distribution of parameters
#' \code{(1,K/mean(X)_i)} where \code{mean(X)_i} is the rowwise mean of
#' the corresponding row in the input data matrix \code{X}.
#' This input parameter is not used if the input parameter \code{U} is not NULL.
#' @param a2 matrix of dimension \code{n x K}, initial values for the
#' variational rate parameter of the Gamma variational distribution over the
#' factor \code{U}. Default is NULL and \code{a2} is intialized with
#' a matrix of 1. This input parameter is not used if the input
#' parameter \code{U} is not NULL.
#' @param b1 matrix of dimension \code{p x K}, initial values for the
#' variational shape parameter of the Gamma variational distribution over the
#' factor \code{V}. Default is NULL and each row \code{j} in \code{b1} is
#' randomly initialized from a Gamma distribution of parameters
#' \code{(1,K/mean(X)_j)} where \code{mean(X)_j} is the colwise mean of
#' the corresponding column in the input data matrix \code{X}.
#' This input parameter is not used if the input parameter \code{V} is not NULL.
#' @param b2 matrix of dimension \code{p x K}, initial values for the
#' variational rate parameter of the Gamma variational distribution over the
#' factor \code{V}. Default is NULL and \code{a2} is intialized with
#' a matrix of 1. This input parameter is not used if the input
#' parameter \code{V} is not NULL.
#' @param alpha1 matrix of dimension \code{n x K}, initial values for the
#' prior shape parameter of the Gamma variational distribution over the
#' factor \code{U}. Default is NULL and \code{alpha1} is initialized based
#' on update rules derived in Durif et al. (2017). This input parameter is
#' not used if the input parameter \code{U} is not NULL. Note: in the
#' standard GaP factor model, all row of \code{alpha1} should be identical.
#' @param alpha2 matrix of dimension \code{n x K}, initial values for the
#' prior rate parameter of the Gamma variational distribution over the
#' factor \code{U}. Default is NULL and \code{alpha2} is initialized based
#' on update rules derived in Durif et al. (2017). This input parameter is
#' not used if the input parameter \code{U} is not NULL. Note: in the
#' standard GaP factor model, all row of \code{alpha2} should be identical.
#' @param beta1 matrix of dimension \code{p x K}, initial values for the
#' prior shape parameter of the Gamma variational distribution over the
#' factor \code{V}. Default is NULL and \code{beta1} is initialized based
#' on update rules derived in Durif et al. (2017). This input parameter is
#' not used if the input parameter \code{U} is not NULL. Note: in the
#' standard GaP factor model, all row of \code{beta1} should be identical.
#' @param beta2 matrix of dimension \code{p x K}, initial values for the
#' prior rate parameter of the Gamma variational distribution over the
#' factor \code{V}. Default is NULL and \code{beta2} is initialized based
#' on update rules derived in Durif et al. (2017). This input parameter is
#' not used if the input parameter \code{U} is not NULL. Note: in the
#' standard GaP factor model, all row of \code{beta2} should be identical.
#'
#' Note: input parameters \code{a1}, \code{a2}, \code{b1}, \code{b2} should
#' all be set to be used. Similarly, \code{alpha1}, \code{alpha2},
#' \code{beta1}, \code{beta2} should all be set to be used.
#'
#' @import Rcpp
#' @import RcppEigen
#' @importFrom Rcpp evalCpp
#' @useDynLib pCMF, .registration = TRUE
#'
#' @return list of Poisson NMF output
#' \item{factor}{list of estimated factor matrices:
#'     \code{U}: matrix of dimension \code{n x K}, representation of
#'     individuals in the subspace of dimension \code{K}.
#'     \code{V}: matrix of dimension \code{p x K}, contributions of variables
#'     to the subspace of dimension \code{K}.}
#' \item{convergence}{list of items related to the algorithm convergence:
#'     \code{converged}: boolean indicating if convergence was reached.
#'     \code{nb_iter}: integer, number of effective iterations.
#'     \code{conv_mode}: input \code{conv_mode} parameter.
#'     \code{conv_crit}: vector of size \code{nb_iter}, values of the
#'     convergence criterion across iterations.}
#' \item{loss}{vector of size \code{nb_iter}, values of the loss
#' across iterations.}
#' \item{monitor}{list of monitored criteria if \code{conv_mode} input
#' parameter was set to 1, not returned otherwise:
#'     \code{norm_gap}: vector of size \code{nb_iter}, values of normalized
#'     gap between iterates across iterations.
#'     \code{abs_gap}: vector of size \code{nb_iter}, values of absolute
#'     gap between iterates across iterations.
#'     \code{loglikelihood}: vector of size \code{nb_iter}, values of the
#'     log-likelihood associated to the Poisson NMF model across iterations.
#'     \code{deviance}: vector of size \code{nb_iter}, values of the
#'     deviance associated to the Poisson NMF model across iterations.}
#' \item{variational_params}{list of estimated value for variational
#' parameters:
#'     \code{a1} and \code{a2}: matrix of dimension \code{n x K}.
#'     \code{b1} and \code{b2}: matrix of dimension \code{p x K}.}
#' \item{hyper_params}{list of estimated value for hyper parameters:
#'     \code{alpha1} and \code{alpha2}: matrix of dimension \code{n x K}.
#'     \code{beta1} and \code{beta2}: matrix of dimension \code{p x K}.}
#' \item{stats}{list of exhaustive statistics relaed to the variational
#' distribution:
#'     \code{EU}: expectation of U, matrix of dimension \code{n x K}.
#'     \code{ElogU}: expectation of log U, matrix of dimension \code{n x K}.
#'     \code{EV}: expectation of V, matrix of dimension \code{p x K}.
#'     \code{ElogV}: expectation of log V, matrix of dimension \code{p x K}.}
#' \item{seed}{positive integer value corresponding to the value given as
#' seed in input parameter for random number generation.}
#'
#' @examples
#' \dontrun{
#' ## generate data
#' n <- 100
#' p <- 200
#' K <- 10
#' factorU <- generate_factor_matrix(n, K, ngroup=3, average_signal=60,
#'                                   group_separation=0.8,
#'                                   distribution="gamma",
#'                                   shuffle_feature=TRUE)
#' factorV <- generate_factor_matrix(p, K, ngroup=2, average_signal=60,
#'                                   group_separation=0.8,
#'                                   distribution="gamma",
#'                                   shuffle_feature=TRUE)
#' U <- factorU$factor_matrix
#' V <- factorV$factor_matrix
#' count_data <- generate_count_matrix(n, p, K, U, V)
#' X <- count_data$X
#' ## or use your own data as a count matrix
#' ## of dimension cells x genes (individuals x features)
#' ## run matrix factorization algorithm
#' res <- run_gap_factor(X, K, verbose=FALSE)
#' }
#'
#' @export
run_gap_factor <- function(X, K, U = NULL, V = NULL, verbose = TRUE, monitor = TRUE, iter_max = 1000L, iter_min = 500L, init_mode = "random", epsilon = 1e-2, additional_iter = 10L, conv_mode = 1L, ninit = 1L, iter_init = 100L, ncores = 1L, reorder_factor = TRUE, seed = NULL, a1 = NULL, a2 = NULL, b1 = NULL, b2 = NULL, alpha1 = NULL, alpha2 = NULL, beta1 = NULL, beta2 = NULL) {
    .Call(`_pCMF_run_gap_factor`, X, K, U, V, verbose, monitor, iter_max, iter_min, init_mode, epsilon, additional_iter, conv_mode, ninit, iter_init, ncores, reorder_factor, seed, a1, a2, b1, b2, alpha1, alpha2, beta1, beta2)
}

#' @title run_poisson_nmf
#' @name run_poisson_nmf
#'
#' @description
#' Re-implementation of the Non-Negative Matrix Factorization (NMF) in
#' the Poisson framework.
#'
#' @details
#' Wrapper for a Cpp function.
#'
#' In the Non-negative Matrix Factorization framework (NMF), the count data
#' matrix \eqn{X} (dim \eqn{n \times p}) is approximated by a matrix product
#' \eqn{U V^t} where \eqn{U_{n\times K}} and \eqn{V_{p\times K}} respectively
#' represent the individuals (rows of \eqn{X}) and variables (cols of \eqn{X})
#' in a sub-space of dimension \eqn{K}.
#'
#' In the Poisson NMF framework, the approximation between \eqn{X} and
#' \eqn{U V^t} is made regarding the Kullback-Leibler divergence, which
#' corresponds to the Bregman divergence derived from the model
#' \eqn{X \sim P(U V^t)}, i.e. each entry \eqn{X_{ij}} is assumed to follow
#' a Poisson distribution of parameter \eqn{\sum_k U_{ik} V_{jk}}.
#'
#' More details regarding Poisson NMF can be found in Brunet et al. (2004),
#' the original implementation of NMF in R was done by Gaujoux
#' and Seoighe (2010). The generalization of Principal Component Analysis
#' based on Bregman divergence is discussed in Collins et al. (2001).
#'
#' @references
#' Brunet, J.-P., Tamayo, P., Golub, T.R., Mesirov, J.P., 2004.
#' Metagenes and molecular pattern discovery using matrix factorization.
#' PNAS 101, 4164–4169.
#'
#' Collins, M., Dasgupta, S., Schapire, R.E., 2001.
#' A generalization of principal components analysis to the exponential family.
#' Advances in Neural Information Processing Systems. pp. 617–624.
#'
#' Gaujoux, R., Seoighe, C., 2010.
#' A flexible R package for nonnegative matrix factorization.
#' BMC Bioinformatics 11, 367.
#'
#' @author
#' Ghislain Durif, \email{gd.dev@libertymail.net}
#'
#' @param X a count data matrix of dimension \code{n x p}.
#' @param K integer, required dimension of the subspace for the latent
#' representation.
#' @param U matrix of dimension \code{n x K}, initial values for the factor
#' matrix U. Default is NULL and U is randomly initialized from
#' a Uniform distribution on (0,1).
#' @param V matrix of dimension \code{p x K}, initial values for the factor
#' matrix V. Default is NULL and V is randomly initialized from
#' a Uniform distribution on (0,1).
#' @param verbose boolean indicating verbosity. Default is True.
#' @param monitor boolean indicating if model related measures
#' (log-likelihood, deviance, Bregman divergence between \eqn{X}
#' and \eqn{UV^t}) should be computed. Default is True.
#' @param iter_max integer, maximum number of iterations after which the
#' optimization is stopped even when the algorithm did not converge.
#' Default is 1000.
#' @param iter_min integer, minimum number of iterations without checking
#' convergence. Default is 500.
#' @param epsilon double precision parameter to assess convergence, i.e.
#' the convergence is reached when the gap (absolute or normalized) between
#' two iterates becomes smaller than epsilon. Default is 1e-2.
#' @param additional_iter integer, number of successive iterations during
#' which the convergence criterion should be verified to assess convergence.
#' @param conv_mode \{0,1,2\}-valued indicator setting how to assess
#' convergence: 0 for absolute gap, 1 for normalized gap and 2 for
#' RV coefficient between two iterates. Default is 1.
#' @param ninit integer, number of initialization to consider. In multiple
#' initialization mode (>1), the algorithm is run for
#' \code{iter_init} iterations with mutliple seeds and the best one
#' (regarding the optimization criterion) is kept. If \code{U} and \code{V}
#' are supplied, each seed uses a pertubated version of \code{U} and \code{V}
#' as initial values. Default value is 1.
#' @param iter_init integer, number of iterations during which the algorithms
#' is run in multi-initialization mode. Default value is 100.
#' @param ncores integer indicating the number of cores to use for
#' parallel computation. Default is 1 and no multi-threading is used.
#' @param reorder_factor boolean indicating if factors should be reordered
#' according to the model-related deviance criterion. Default value is True.
#' @param seed positive integer, seed value for random number generator.
#' Default is NULL and the seed is set based on the current time.
#'
#' @import Rcpp
#' @import RcppEigen
#' @importFrom Rcpp evalCpp
#' @useDynLib pCMF, .registration = TRUE
#'
#' @return list of Poisson NMF output
#' \item{factor}{list of estimated factor matrices:
#'     \code{U}: matrix of dimension \code{n x K}, representation of
#'     individuals in the subspace of dimension \code{K}.
#'     \code{V}: matrix of dimension \code{p x K}, contributions of variables
#'     to the subspace of dimension \code{K}.}
#' \item{convergence}{list of items related to the algorithm convergence:
#'     \code{converged}: boolean indicating if convergence was reached.
#'     \code{nb_iter}: integer, number of effective iterations.
#'     \code{conv_mode}: input \code{conv_mode} parameter.
#'     \code{conv_crit}: vector of size \code{nb_iter}, values of the
#'     convergence criterion across iterations.}
#' \item{loss}{double, values of the loss after iterations.}
#' \item{monitor}{list of monitored criteria if \code{conv_mode} input
#' parameter was set to 1, not returned otherwise:
#'     \code{norm_gap}: vector of size \code{nb_iter}, values of normalized
#'     gap between iterates across iterations.
#'     \code{abs_gap}: vector of size \code{nb_iter}, values of absolute
#'     gap between iterates across iterations.
#'     \code{loglikelihood}: vector of size \code{nb_iter}, values of the
#'     log-likelihood associated to the Poisson NMF model across iterations.
#'     \code{deviance}: vector of size \code{nb_iter}, values of the
#'     deviance associated to the Poisson NMF model across iterations.
#'     \code{optim_criterion}: vector of size \code{nb_iter}, values of the
#'     loss across iterations.}
#' \item{seed}{positive integer value corresponding to the value given as
#' seed in input parameter for random number generation.}
#'
#' @examples
#' \dontrun{
#' ## generate data
#' n <- 100
#' p <- 50
#' K <- 5
#' factorU <- generate_factor_matrix(n, K, ngroup=3, average_signal=0.5*K,
#'                                   group_separation=0.5,
#'                                   distribution="uniform",
#'                                   shuffle_feature=TRUE)
#' factorV <- generate_factor_matrix(p, K, ngroup=2, average_signal=0.5*K,
#'                                   group_separation=0.5,
#'                                   distribution="uniform",
#'                                   shuffle_feature=TRUE)
#' U <- factorU$factor_matrix
#' V <- factorV$factor_matrix
#' count_data <- generate_count_matrix(n, p, K, U, V)
#' X <- count_data$X
#' ## run matrix factorization algorithm
#' res <- run_poisson_nmf(X, K, verbose=FALSE)
#' }
#'
#' @export
run_poisson_nmf <- function(X, K, U = NULL, V = NULL, verbose = TRUE, monitor = TRUE, iter_max = 1000L, iter_min = 500L, epsilon = 1e-2, additional_iter = 10L, conv_mode = 1L, ninit = 1L, iter_init = 100L, ncores = 1L, reorder_factor = TRUE, seed = NULL) {
    .Call(`_pCMF_run_poisson_nmf`, X, K, U, V, verbose, monitor, iter_max, iter_min, epsilon, additional_iter, conv_mode, ninit, iter_init, ncores, reorder_factor, seed)
}

#' @title run_sparse_gap_factor
#' @name run_sparse_gap_factor
#'
#' @description
#' Implementation of the probabilistic Count Matrix Factorization (pCMF)
#' method based on the Gamma-Poisson hirerarchical factor model, with
#' sparisty-inducing priors on factor V. This method is specifically designed
#' to analyze count matrices such as gene expression profiles (RNA-seq)
#' obtained by high throughput sequencing.
#'
#' @details
#' Wrapper for a Cpp function.
#'
#' In the probabilistic Count Matrix Factorization framework (pCMF), the
#' count data matrix \eqn{X} (dim \eqn{n \times p}) is approximated
#' by a matrix product \eqn{U V^t} where \eqn{U_{n\times K}} and
#' \eqn{V_{p\times K}} respectively represent the individuals
#' (rows of \eqn{X}) and variables (cols of \eqn{X})
#' in a sub-space of dimension \eqn{K}.
#'
#' In the pCMF framework, the approximation between \eqn{X} and
#' \eqn{U V^t} is made regarding the Kullback-Leibler divergence, which
#' corresponds to the Bregman divergence derived from the model
#' \eqn{X \sim P(U V^t)}, i.e. each entry \eqn{X_{ij}} is assumed to follow
#' a Poisson distribution of parameter \eqn{\sum_k U_{ik} V_{jk}}.
#' In addition, factors \eqn{U_{ik}} and \eqn{V_{jk}} are assumed to
#' be independent latent random variables following Gamma distributions.
#' In particular, each \eqn{V_{jk}} follows a Dirac-Gamma mixture, which
#' induces sparsity in matrix \eqn{V}.
#'
#' More details regarding pCMF can be found in Durif et al. (2017).
#'
#' @references
#' Durif, G., Modolo, L., Mold, J.E., Lambert-Lacroix, S., Picard, F., 2017.
#' Probabilistic Count Matrix Factorization for Single Cell Expression Data
#' Analysis. arXiv:1710.11028 [stat].
#'
#' @author
#' Ghislain Durif, \email{gd.dev@libertymail.net}
#'
#' @param X a count data matrix of dimension \code{n x p}.
#' @param K integer, required dimension of the subspace for the latent
#' representation.
#' @param sel_bound real value in [0,1] used to threshold sparsity
#' probabilities for factor V.
#' @param U matrix of dimension \code{n x K}, initial values for the factor
#' matrix \code{U}. It is used to intialized the variational parameter of the
#' varitional distribution over the factor \code{U}. Default is NULL and
#' variational parameters over \code{U} are intialized otherwise.
#' Note: if you supply \code{U} input parameter, you should supply
#' \code{V} input parameter.
#' @param V matrix of dimension \code{p x K}, initial values for the factor
#' matrix \code{V}. It is used to intialized the variational parameter of the
#' varitional distribution over the factor \code{V}. Default is NULL and
#' variational parameters over \code{V} are intialized otherwise.
#' Note: if you supply \code{V} input parameter, you should supply
#' \code{U} input parameter.
#' @param verbose boolean indicating verbosity. Default is True.
#' @param monitor boolean indicating if model related measures
#' (log-likelihood, deviance, Bregman divergence between \eqn{X}
#' and \eqn{UV^t}) should be computed. Default is True.
#' @param iter_max integer, maximum number of iterations after which the
#' optimization is stopped even when the algorithm did not converge.
#' Default is 1000.
#' @param iter_min integer, minimum number of iterations without checking
#' convergence. Default is 500.
#' @param init_mode string, intialization mode to choose between "random",
#' "nmf". Default value is "random". Unused if initial values are given
#' for U and V or a1, a2, b1 and b2.
#' @param epsilon double precision parameter to assess convergence, i.e.
#' the convergence is reached when the gap (absolute or normalized) between
#' two iterates becomes smaller than epsilon. Default is 1e-2.
#' @param additional_iter integer, number of successive iterations during
#' which the convergence criterion should be verified to assess convergence.
#' @param conv_mode \{0,1,2\}-valued indicator setting how to assess
#' convergence: 0 for absolute gap, 1 for normalized gap between
#' two iterates and 2 for custom criterion (depends on the considered
#' method/model). Default is 1.
#' @param ninit integer, number of initialization to consider. In multiple
#' initialization mode (>1), the algorithm is run for \code{iter_init}
#' iterations with mutliple seeds and the best one (regarding the optimization
#' criterion) is kept. Default value is 1.
#' @param iter_init integer, number of iterations during which the algorithms
#' is run in multi-initialization mode. Default value is 100.
#' @param ncores integer indicating the number of cores to use for
#' parallel computation. Default is 1 and no multi-threading is used.
#' @param reorder_factor boolean indicating if factors should be reordered
#' according to the model-related deviance criterion. Default value is True.
#' @param seed positive integer, seed value for random number generator.
#' Default is NULL and the seed is set based on the current time.
#' @param a1 matrix of dimension \code{n x K}, initial values for the
#' variational shape parameter of the Gamma variational distribution over the
#' factor \code{U}. Default is NULL and each row \code{i} in \code{a1} is
#' randomly initialized from a Gamma distribution of parameters
#' \code{(1,K/mean(X)_i)} where \code{mean(X)_i} is the rowwise mean of
#' the corresponding row in the input data matrix \code{X}.
#' This input parameter is not used if the input parameter \code{U} is not NULL.
#' @param a2 matrix of dimension \code{n x K}, initial values for the
#' variational rate parameter of the Gamma variational distribution over the
#' factor \code{U}. Default is NULL and \code{a2} is intialized with
#' a matrix of 1. This input parameter is not used if the input
#' parameter \code{U} is not NULL.
#' @param b1 matrix of dimension \code{p x K}, initial values for the
#' variational shape parameter of the Gamma variational distribution over the
#' factor \code{V}. Default is NULL and each row \code{j} in \code{b1} is
#' randomly initialized from a Gamma distribution of parameters
#' \code{(1,K/mean(X)_j)} where \code{mean(X)_j} is the colwise mean of
#' the corresponding column in the input data matrix \code{X}.
#' This input parameter is not used if the input parameter \code{V} is not NULL.
#' @param b2 matrix of dimension \code{p x K}, initial values for the
#' variational rate parameter of the Gamma variational distribution over the
#' factor \code{V}. Default is NULL and \code{a2} is intialized with
#' a matrix of 1. This input parameter is not used if the input
#' parameter \code{V} is not NULL.
#' @param alpha1 matrix of dimension \code{n x K}, initial values for the
#' prior shape parameter of the Gamma variational distribution over the
#' factor \code{U}. Default is NULL and \code{alpha1} is initialized based
#' on update rules derived in Durif et al. (2017). This input parameter is
#' not used if the input parameter \code{U} is not NULL. Note: in the
#' standard GaP factor model, all row of \code{alpha1} should be identical.
#' @param alpha2 matrix of dimension \code{n x K}, initial values for the
#' prior rate parameter of the Gamma variational distribution over the
#' factor \code{U}. Default is NULL and \code{alpha2} is initialized based
#' on update rules derived in Durif et al. (2017). This input parameter is
#' not used if the input parameter \code{U} is not NULL. Note: in the
#' standard GaP factor model, all row of \code{alpha2} should be identical.
#' @param beta1 matrix of dimension \code{p x K}, initial values for the
#' prior shape parameter of the Gamma variational distribution over the
#' factor \code{V}. Default is NULL and \code{beta1} is initialized based
#' on update rules derived in Durif et al. (2017). This input parameter is
#' not used if the input parameter \code{U} is not NULL. Note: in the
#' standard GaP factor model, all row of \code{beta1} should be identical.
#' @param beta2 matrix of dimension \code{p x K}, initial values for the
#' prior rate parameter of the Gamma variational distribution over the
#' factor \code{V}. Default is NULL and \code{beta2} is initialized based
#' on update rules derived in Durif et al. (2017). This input parameter is
#' not used if the input parameter \code{U} is not NULL. Note: in the
#' standard GaP factor model, all row of \code{beta2} should be identical.
#' @param prob_S matrix of dimension \code{p x K}, initial values for the
#' variational probability parameter for the sparsity indicator matrix \code{S}
#' over the factor \code{V}. Default is NULL and \code{prob_S} is initialized
#' randomly.
#' @param prior_S vector of length \code{p}, initial values for the
#' prior probability parameter for the sparsity indicator matrix \code{S} over
#' the factor \code{V}. Default is NULL and \code{prior_S} is initialized
#' randomly.
#'
#' Note: input parameters \code{a1}, \code{a2}, \code{b1}, \code{b2} should
#' all be set to be used. Similarly, \code{alpha1}, \code{alpha2},
#' \code{beta1}, \code{beta2} should all be set to be used.
#'
#' @import Rcpp
#' @import RcppEigen
#' @importFrom Rcpp evalCpp
#' @useDynLib pCMF, .registration = TRUE
#'
#' @return list of Poisson NMF output
#' \item{factor}{list of estimated factor matrices:
#'     \code{U}: matrix of dimension \code{n x K}, representation of
#'     individuals in the subspace of dimension \code{K}.
#'     \code{V}: matrix of dimension \code{p x K}, contributions of variables
#'     to the subspace of dimension \code{K}.}
#' \item{convergence}{list of items related to the algorithm convergence:
#'     \code{converged}: boolean indicating if convergence was reached.
#'     \code{nb_iter}: integer, number of effective iterations.
#'     \code{conv_mode}: input \code{conv_mode} parameter.
#'     \code{conv_crit}: vector of size \code{nb_iter}, values of the
#'     convergence criterion across iterations.}
#' \item{loss}{double, values of the loss after iterations.}
#' \item{monitor}{list of monitored criteria if \code{conv_mode} input
#' parameter was set to 1, not returned otherwise:
#'     \code{norm_gap}: vector of size \code{nb_iter}, values of normalized
#'     gap between iterates across iterations.
#'     \code{abs_gap}: vector of size \code{nb_iter}, values of absolute
#'     gap between iterates across iterations.
#'     \code{loglikelihood}: vector of size \code{nb_iter}, values of the
#'     log-likelihood associated to the Poisson NMF model across iterations.
#'     \code{deviance}: vector of size \code{nb_iter}, values of the
#'     deviance associated to the Poisson NMF model across iterations.
#'     \code{optim_criterion}: vector of size \code{nb_iter}, values of the
#'     loss across iterations.}
#' \item{variational_params}{list of estimated value for variational
#' parameters:
#'     \code{a1} and \code{a2}: matrix of dimension \code{n x K}.
#'     \code{b1} and \code{b2}: matrix of dimension \code{p x K}.}
#' \item{hyper_params}{list of estimated value for hyper parameters:
#'     \code{alpha1} and \code{alpha2}: matrix of dimension \code{n x K}.
#'     \code{beta1} and \code{beta2}: matrix of dimension \code{p x K}.}
#' \item{stats}{list of exhaustive statistics relaed to the variational
#' distribution:
#'     \code{EU}: expectation of U, matrix of dimension \code{n x K}.
#'     \code{ElogU}: expectation of log U, matrix of dimension \code{n x K}.
#'     \code{EV}: expectation of V, matrix of dimension \code{p x K}.
#'     \code{ElogV}: expectation of log V, matrix of dimension \code{p x K}.}
#' \item{sparse_param}{list of estimated values for variational and hyper
#' parameters regarding sparsity in \code{V} (see Durif et al. (2017) for
#' more details):
#'     \code{prob_S}: matrix of size \code{p x K}, variational probabilities
#'     for each entry \eqn{V_{jk}} to be non-null.
#'     \code{prior_prob_S}: vector of size \code{p}, estimated prior
#'     probability for each variable/gene to contribute in \code{V}.
#'     \code{S}: matrix of size \code{p x K}, matrix of indicators \eqn{S_{jk}}
#'     correspondings to null (if 0) and non-null (if 1) entries \eqn{V_{jk}}
#'     according to variational distribution.}
#' \item{seed}{positive integer value corresponding to the value given as
#' seed in input parameter for random number generation.}
#'
#' expect_true(is.list(res$sparse_param))
#'
#' @examples
#' \dontrun{
#' ## generate data
#' n <- 100
#' p <- 200
#' K <- 10
#' factorU <- generate_factor_matrix(n, K, ngroup=3, average_signal=60,
#'                                   group_separation=0.8,
#'                                   distribution="gamma",
#'                                   shuffle_feature=TRUE)
#' factorV <- generate_factor_matrix(p, K, ngroup=2, average_signal=60,
#'                                   group_separation=0.8,
#'                                   distribution="gamma",
#'                                   shuffle_feature=TRUE,
#'                                   prop_noise_feature=0.5)
#' U <- factorU$factor_matrix
#' V <- factorV$factor_matrix
#' count_data <- generate_count_matrix(n, p, K, U, V)
#' X <- count_data$X
#' ## or use your own data as a count matrix
#' ## of dimension cells x genes (individuals x features)
#' ## run matrix factorization algorithm
#' res <- run_sparse_gap_factor(X, K, verbose=FALSE)
#' }
#'
#' @export
run_sparse_gap_factor <- function(X, K, sel_bound = 0.5, U = NULL, V = NULL, verbose = TRUE, monitor = TRUE, iter_max = 1000L, iter_min = 500L, init_mode = "random", epsilon = 1e-2, additional_iter = 10L, conv_mode = 1L, ninit = 1L, iter_init = 100L, ncores = 1L, reorder_factor = TRUE, seed = NULL, a1 = NULL, a2 = NULL, b1 = NULL, b2 = NULL, alpha1 = NULL, alpha2 = NULL, beta1 = NULL, beta2 = NULL, prob_S = NULL, prior_S = NULL) {
    .Call(`_pCMF_run_sparse_gap_factor`, X, K, sel_bound, U, V, verbose, monitor, iter_max, iter_min, init_mode, epsilon, additional_iter, conv_mode, ninit, iter_init, ncores, reorder_factor, seed, a1, a2, b1, b2, alpha1, alpha2, beta1, beta2, prob_S, prior_S)
}

#' @title run_zi_gap_factor
#' @name run_zi_gap_factor
#'
#' @description
#' Implementation of the probabilistic Count Matrix Factorization (pCMF)
#' method based on the Gamma-Poisson hirerarchical factor model. This method
#' is specifically designed to analyze count matrices with drop-out events
#' (also called zero-inflation) such as gene expression profiles from single
#' cells (scRNA-seq) obtained by high throughput sequencing.
#'
#' @details
#' Wrapper for a Cpp function.
#'
#' In the probabilistic Count Matrix Factorization framework (pCMF), the
#' count data matrix \eqn{X} (dim \eqn{n \times p}) is approximated
#' by a matrix product \eqn{U V^t} where \eqn{U_{n\times K}} and
#' \eqn{V_{p\times K}} respectively represent the individuals
#' (rows of \eqn{X}) and variables (cols of \eqn{X})
#' in a sub-space of dimension \eqn{K}.
#'
#' In the pCMF framework, the approximation between \eqn{X} and
#' \eqn{U V^t} is made regarding the Kullback-Leibler divergence, which
#' corresponds to the Bregman divergence derived from the model
#' \eqn{X \sim P(U V^t)}, i.e. each entry \eqn{X_{ij}} is assumed to follow
#' a zero-inflated Poisson distribution, which corresponds to a Dirac-Poisson
#' mixture, where Poisson parameter is \eqn{\sum_k U_{ik} V_{jk}}.
#' In addition, factors \eqn{U_{ik}} and \eqn{V_{jk}} are assumed to
#' be independent latent random variables following Gamma distributions.
#'
#' More details regarding pCMF can be found in Durif et al. (2017).
#'
#' @references
#' Durif, G., Modolo, L., Mold, J.E., Lambert-Lacroix, S., Picard, F., 2017.
#' Probabilistic Count Matrix Factorization for Single Cell Expression Data
#' Analysis. arXiv:1710.11028 [stat].
#'
#' @author
#' Ghislain Durif, \email{gd.dev@libertymail.net}
#'
#' @param X a count data matrix of dimension \code{n x p}.
#' @param K integer, required dimension of the subspace for the latent
#' representation.
#' @param U matrix of dimension \code{n x K}, initial values for the factor
#' matrix \code{U}. It is used to intialized the variational parameter of the
#' varitional distribution over the factor \code{U}. Default is NULL and
#' variational parameters over \code{U} are intialized otherwise.
#' Note: if you supply \code{U} input parameter, you should supply
#' \code{V} input parameter.
#' @param V matrix of dimension \code{p x K}, initial values for the factor
#' matrix \code{V}. It is used to intialized the variational parameter of the
#' varitional distribution over the factor \code{V}. Default is NULL and
#' variational parameters over \code{V} are intialized otherwise.
#' Note: if you supply \code{V} input parameter, you should supply
#' \code{U} input parameter.
#' @param verbose boolean indicating verbosity. Default is True.
#' @param monitor boolean indicating if model related measures
#' (log-likelihood, deviance, Bregman divergence between \eqn{X}
#' and \eqn{UV^t}) should be computed. Default is True.
#' @param iter_max integer, maximum number of iterations after which the
#' optimization is stopped even when the algorithm did not converge.
#' Default is 1000.
#' @param iter_min integer, minimum number of iterations without checking
#' convergence. Default is 500.
#' @param init_mode string, intialization mode to choose between "random",
#' "nmf". Default value is "random". Unused if initial values are given
#' for U and V or a1, a2, b1 and b2.
#' @param epsilon double precision parameter to assess convergence, i.e.
#' the convergence is reached when the gap (absolute or normalized) between
#' two iterates becomes smaller than epsilon. Default is 1e-2.
#' @param additional_iter integer, number of successive iterations during
#' which the convergence criterion should be verified to assess convergence.
#' @param conv_mode \{0,1,2\}-valued indicator setting how to assess
#' convergence: 0 for absolute gap, 1 for normalized gap between
#' two iterates and 2 for custom criterion (depends on the considered
#' method/model). Default is 1.
#' @param ninit integer, number of initialization to consider. In multiple
#' initialization mode (>1), the algorithm is run for \code{iter_init}
#' iterations with mutliple seeds and the best one (regarding the optimization
#' criterion) is kept. Default value is 1.
#' @param iter_init integer, number of iterations during which the algorithms
#' is run in multi-initialization mode. Default value is 100.
#' @param ncores integer indicating the number of cores to use for
#' parallel computation. Default is 1 and no multi-threading is used.
#' @param reorder_factor boolean indicating if factors should be reordered
#' according to the model-related deviance criterion. Default value is True.
#' @param seed positive integer, seed value for random number generator.
#' Default is NULL and the seed is set based on the current time.
#' @param a1 matrix of dimension \code{n x K}, initial values for the
#' variational shape parameter of the Gamma variational distribution over the
#' factor \code{U}. Default is NULL and each row \code{i} in \code{a1} is
#' randomly initialized from a Gamma distribution of parameters
#' \code{(1,K/mean(X)_i)} where \code{mean(X)_i} is the rowwise mean of
#' the corresponding row in the input data matrix \code{X}.
#' This input parameter is not used if the input parameter \code{U} is not NULL.
#' @param a2 matrix of dimension \code{n x K}, initial values for the
#' variational rate parameter of the Gamma variational distribution over the
#' factor \code{U}. Default is NULL and \code{a2} is intialized with
#' a matrix of 1. This input parameter is not used if the input
#' parameter \code{U} is not NULL.
#' @param b1 matrix of dimension \code{p x K}, initial values for the
#' variational shape parameter of the Gamma variational distribution over the
#' factor \code{V}. Default is NULL and each row \code{j} in \code{b1} is
#' randomly initialized from a Gamma distribution of parameters
#' \code{(1,K/mean(X)_j)} where \code{mean(X)_j} is the colwise mean of
#' the corresponding column in the input data matrix \code{X}.
#' This input parameter is not used if the input parameter \code{V} is not NULL.
#' @param b2 matrix of dimension \code{p x K}, initial values for the
#' variational rate parameter of the Gamma variational distribution over the
#' factor \code{V}. Default is NULL and \code{a2} is intialized with
#' a matrix of 1. This input parameter is not used if the input
#' parameter \code{V} is not NULL.
#' @param alpha1 matrix of dimension \code{n x K}, initial values for the
#' prior shape parameter of the Gamma variational distribution over the
#' factor \code{U}. Default is NULL and \code{alpha1} is initialized based
#' on update rules derived in Durif et al. (2017). This input parameter is
#' not used if the input parameter \code{U} is not NULL. Note: in the
#' standard GaP factor model, all row of \code{alpha1} should be identical.
#' @param alpha2 matrix of dimension \code{n x K}, initial values for the
#' prior rate parameter of the Gamma variational distribution over the
#' factor \code{U}. Default is NULL and \code{alpha2} is initialized based
#' on update rules derived in Durif et al. (2017). This input parameter is
#' not used if the input parameter \code{U} is not NULL. Note: in the
#' standard GaP factor model, all row of \code{alpha2} should be identical.
#' @param beta1 matrix of dimension \code{p x K}, initial values for the
#' prior shape parameter of the Gamma variational distribution over the
#' factor \code{V}. Default is NULL and \code{beta1} is initialized based
#' on update rules derived in Durif et al. (2017). This input parameter is
#' not used if the input parameter \code{U} is not NULL. Note: in the
#' standard GaP factor model, all row of \code{beta1} should be identical.
#' @param beta2 matrix of dimension \code{p x K}, initial values for the
#' prior rate parameter of the Gamma variational distribution over the
#' factor \code{V}. Default is NULL and \code{beta2} is initialized based
#' on update rules derived in Durif et al. (2017). This input parameter is
#' not used if the input parameter \code{U} is not NULL. Note: in the
#' standard GaP factor model, all row of \code{beta2} should be identical.
#' @param prob_D matrix of dimension \code{n x p}, initial values for the
#' variational probability parameter for the drop-out indicator matrix \code{D}
#' accounting for zero-inflation in \code{X}. Default is NULL
#' and \code{prob_D} is initialized by the frequence of zero in the
#' corresponding column of \code{X}. This parameter is not used for model
#' without zero-inflation.
#' @param prior_D vector of length \code{p}, initial values for the
#' prior probability parameter for the drop-out indicator matrix \code{D}
#' accounting for zero-inflation in \code{X}. Default is NULL and
#' \code{prior_D} is initialized by the frequence of zero in the
#' corresponding column of \code{X}. This parameter is not used for model
#' without zero-inflation.
#'
#' Note: input parameters \code{a1}, \code{a2}, \code{b1}, \code{b2} should
#' all be set to be used. Similarly, \code{alpha1}, \code{alpha2},
#' \code{beta1}, \code{beta2} should all be set to be used.
#'
#' @import Rcpp
#' @import RcppEigen
#' @importFrom Rcpp evalCpp
#' @useDynLib pCMF, .registration = TRUE
#'
#' @return list of Poisson NMF output
#' \item{factor}{list of estimated factor matrices:
#'     \code{U}: matrix of dimension \code{n x K}, representation of
#'     individuals in the subspace of dimension \code{K}.
#'     \code{V}: matrix of dimension \code{p x K}, contributions of variables
#'     to the subspace of dimension \code{K}.}
#' \item{convergence}{list of items related to the algorithm convergence:
#'     \code{converged}: boolean indicating if convergence was reached.
#'     \code{nb_iter}: integer, number of effective iterations.
#'     \code{conv_mode}: input \code{conv_mode} parameter.
#'     \code{conv_crit}: vector of size \code{nb_iter}, values of the
#'     convergence criterion across iterations.}
#' \item{loss}{double, values of the loss after iterations.}
#' \item{monitor}{list of monitored criteria if \code{conv_mode} input
#' parameter was set to 1, not returned otherwise:
#'     \code{norm_gap}: vector of size \code{nb_iter}, values of normalized
#'     gap between iterates across iterations.
#'     \code{abs_gap}: vector of size \code{nb_iter}, values of absolute
#'     gap between iterates across iterations.
#'     \code{loglikelihood}: vector of size \code{nb_iter}, values of the
#'     log-likelihood associated to the Poisson NMF model across iterations.
#'     \code{deviance}: vector of size \code{nb_iter}, values of the
#'     deviance associated to the Poisson NMF model across iterations.
#'     \code{optim_criterion}: vector of size \code{nb_iter}, values of the
#'     loss across iterations.}
#' \item{variational_params}{list of estimated value for variational
#' parameters:
#'     \code{a1} and \code{a2}: matrix of dimension \code{n x K}.
#'     \code{b1} and \code{b2}: matrix of dimension \code{p x K}.}
#' \item{hyper_params}{list of estimated value for hyper parameters:
#'     \code{alpha1} and \code{alpha2}: matrix of dimension \code{n x K}.
#'     \code{beta1} and \code{beta2}: matrix of dimension \code{p x K}.}
#' \item{stats}{list of exhaustive statistics relaed to the variational
#' distribution:
#'     \code{EU}: expectation of U, matrix of dimension \code{n x K}.
#'     \code{ElogU}: expectation of log U, matrix of dimension \code{n x K}.
#'     \code{EV}: expectation of V, matrix of dimension \code{p x K}.
#'     \code{ElogV}: expectation of log V, matrix of dimension \code{p x K}.}
#' \item{ZI_param}{list of estimated values for variational and hyper
#' parameters regarding zero-inflation in \code{X} (see Durif et al. (2017)
#' for more details):
#'     \code{prob_D}: matrix of size \code{n x p}, variational probabilities
#'     for each entry \eqn{X_{ij}} to not be a drop-out event.
#'     \code{freq_D}: vector of size \code{p}, frequence of non-null values
#'     in each column of \code{X}.
#'     \code{prior_prob_D}: vector of size \code{p}, estimated prior
#'     probability for each variable/gene to show drop-out events.}
#' \item{seed}{positive integer value corresponding to the value given as
#' seed in input parameter for random number generation.}
#'
#' @examples
#' \dontrun{
#' ## generate data
#' ## generate data
#' n <- 100
#' p <- 200
#' K <- 10
#' factorU <- generate_factor_matrix(n, K, ngroup=3, average_signal=60,
#'                                   group_separation=0.8,
#'                                   distribution="gamma",
#'                                   shuffle_feature=TRUE)
#' factorV <- generate_factor_matrix(p, K, ngroup=2, average_signal=60,
#'                                   group_separation=0.8,
#'                                   distribution="gamma",
#'                                   shuffle_feature=TRUE)
#' U <- factorU$factor_matrix
#' V <- factorV$factor_matrix
#' count_data <- generate_count_matrix(n, p, K, U, V,
#'                                     ZI=TRUE, prob1=rep(0.3,p))
#' X <- count_data$X
#' ## or use your own data as a count matrix
#' ## of dimension cells x genes (individuals x features)
#' ## run matrix factorization algorithm
#' res <- run_zi_gap_factor(X, K, verbose=FALSE)
#' }
#'
#' @export
run_zi_gap_factor <- function(X, K, U = NULL, V = NULL, verbose = TRUE, monitor = TRUE, iter_max = 1000L, iter_min = 500L, init_mode = "random", epsilon = 1e-2, additional_iter = 10L, conv_mode = 1L, ninit = 1L, iter_init = 100L, ncores = 1L, reorder_factor = TRUE, seed = NULL, a1 = NULL, a2 = NULL, b1 = NULL, b2 = NULL, alpha1 = NULL, alpha2 = NULL, beta1 = NULL, beta2 = NULL, prob_D = NULL, prior_D = NULL) {
    .Call(`_pCMF_run_zi_gap_factor`, X, K, U, V, verbose, monitor, iter_max, iter_min, init_mode, epsilon, additional_iter, conv_mode, ninit, iter_init, ncores, reorder_factor, seed, a1, a2, b1, b2, alpha1, alpha2, beta1, beta2, prob_D, prior_D)
}

#' @title run_zi_sparse_gap_factor
#' @name run_zi_sparse_gap_factor
#'
#' @description
#' Implementation of the probabilistic Count Matrix Factorization (pCMF)
#' method based on the Gamma-Poisson hirerarchical factor model with
#' sparisty-inducing priors on factor V. This method is specifically designed
#' to analyze count matrices with drop-out events (also called zero-inflation)
#' such as gene expression profiles from single-cell data (scRNA-seq)
#' obtained by high throughput sequencing.
#'
#' @details
#' Wrapper for a Cpp function.
#'
#' In the probabilistic Count Matrix Factorization framework (pCMF), the
#' count data matrix \eqn{X} (dim \eqn{n \times p}) is approximated
#' by a matrix product \eqn{U V^t} where \eqn{U_{n\times K}} and
#' \eqn{V_{p\times K}} respectively represent the individuals
#' (rows of \eqn{X}) and variables (cols of \eqn{X})
#' in a sub-space of dimension \eqn{K}.
#'
#' In the pCMF framework, the approximation between \eqn{X} and
#' \eqn{U V^t} is made regarding the Kullback-Leibler divergence, which
#' corresponds to the Bregman divergence derived from the model
#' \eqn{X \sim P(U V^t)}, i.e. each entry \eqn{X_{ij}} is assumed to follow
#' a zero-inflated Poisson distribution, which corresponds to a Dirac-Poisson
#' mixture, where Poisson parameter is \eqn{\sum_k U_{ik} V_{jk}}.
#' In addition, factors \eqn{U_{ik}} and \eqn{V_{jk}} are assumed to
#' be independent latent random variables following Gamma distributions.
#' In particular, each \eqn{V_{jk}} follows a Dirac-Gamma mixture, which
#' induces sparsity in matrix \eqn{V}.
#'
#' More details regarding pCMF can be found in Durif et al. (2017).
#'
#' @references
#' Durif, G., Modolo, L., Mold, J.E., Lambert-Lacroix, S., Picard, F., 2017.
#' Probabilistic Count Matrix Factorization for Single Cell Expression Data
#' Analysis. arXiv:1710.11028 [stat].
#'
#' @author
#' Ghislain Durif, \email{gd.dev@libertymail.net}
#'
#' @param X a count data matrix of dimension \code{n x p}.
#' @param K integer, required dimension of the subspace for the latent
#' representation.
#' @param sel_bound real value in [0,1] used to threshold sparsity
#' probabilities for factor V.
#' @param U matrix of dimension \code{n x K}, initial values for the factor
#' matrix \code{U}. It is used to intialized the variational parameter of the
#' varitional distribution over the factor \code{U}. Default is NULL and
#' variational parameters over \code{U} are intialized otherwise.
#' Note: if you supply \code{U} input parameter, you should supply
#' \code{V} input parameter.
#' @param V matrix of dimension \code{p x K}, initial values for the factor
#' matrix \code{V}. It is used to intialized the variational parameter of the
#' varitional distribution over the factor \code{V}. Default is NULL and
#' variational parameters over \code{V} are intialized otherwise.
#' Note: if you supply \code{V} input parameter, you should supply
#' \code{U} input parameter.
#' @param verbose boolean indicating verbosity. Default is True.
#' @param monitor boolean indicating if model related measures
#' (log-likelihood, deviance, Bregman divergence between \eqn{X}
#' and \eqn{UV^t}) should be computed. Default is True.
#' @param iter_max integer, maximum number of iterations after which the
#' optimization is stopped even when the algorithm did not converge.
#' Default is 1000.
#' @param iter_min integer, minimum number of iterations without checking
#' convergence. Default is 500.
#' @param init_mode string, intialization mode to choose between "random",
#' "nmf". Default value is "random". Unused if initial values are given
#' for U and V or a1, a2, b1 and b2.
#' @param epsilon double precision parameter to assess convergence, i.e.
#' the convergence is reached when the gap (absolute or normalized) between
#' two iterates becomes smaller than epsilon. Default is 1e-2.
#' @param additional_iter integer, number of successive iterations during
#' which the convergence criterion should be verified to assess convergence.
#' @param conv_mode \{0,1,2\}-valued indicator setting how to assess
#' convergence: 0 for absolute gap, 1 for normalized gap between
#' two iterates and 2 for custom criterion (depends on the considered
#' method/model). Default is 1.
#' @param ninit integer, number of initialization to consider. In multiple
#' initialization mode (>1), the algorithm is run for \code{iter_init}
#' iterations with mutliple seeds and the best one (regarding the optimization
#' criterion) is kept. Default value is 1.
#' @param iter_init integer, number of iterations during which the algorithms
#' is run in multi-initialization mode. Default value is 100.
#' @param ncores integer indicating the number of cores to use for
#' parallel computation. Default is 1 and no multi-threading is used.
#' @param reorder_factor boolean indicating if factors should be reordered
#' according to the model-related deviance criterion. Default value is True.
#' @param seed positive integer, seed value for random number generator.
#' Default is NULL and the seed is set based on the current time.
#' @param a1 matrix of dimension \code{n x K}, initial values for the
#' variational shape parameter of the Gamma variational distribution over the
#' factor \code{U}. Default is NULL and each row \code{i} in \code{a1} is
#' randomly initialized from a Gamma distribution of parameters
#' \code{(1,K/mean(X)_i)} where \code{mean(X)_i} is the rowwise mean of
#' the corresponding row in the input data matrix \code{X}.
#' This input parameter is not used if the input parameter \code{U} is not NULL.
#' @param a2 matrix of dimension \code{n x K}, initial values for the
#' variational rate parameter of the Gamma variational distribution over the
#' factor \code{U}. Default is NULL and \code{a2} is intialized with
#' a matrix of 1. This input parameter is not used if the input
#' parameter \code{U} is not NULL.
#' @param b1 matrix of dimension \code{p x K}, initial values for the
#' variational shape parameter of the Gamma variational distribution over the
#' factor \code{V}. Default is NULL and each row \code{j} in \code{b1} is
#' randomly initialized from a Gamma distribution of parameters
#' \code{(1,K/mean(X)_j)} where \code{mean(X)_j} is the colwise mean of
#' the corresponding column in the input data matrix \code{X}.
#' This input parameter is not used if the input parameter \code{V} is not NULL.
#' @param b2 matrix of dimension \code{p x K}, initial values for the
#' variational rate parameter of the Gamma variational distribution over the
#' factor \code{V}. Default is NULL and \code{a2} is intialized with
#' a matrix of 1. This input parameter is not used if the input
#' parameter \code{V} is not NULL.
#' @param alpha1 matrix of dimension \code{n x K}, initial values for the
#' prior shape parameter of the Gamma variational distribution over the
#' factor \code{U}. Default is NULL and \code{alpha1} is initialized based
#' on update rules derived in Durif et al. (2017). This input parameter is
#' not used if the input parameter \code{U} is not NULL. Note: in the
#' standard GaP factor model, all row of \code{alpha1} should be identical.
#' @param alpha2 matrix of dimension \code{n x K}, initial values for the
#' prior rate parameter of the Gamma variational distribution over the
#' factor \code{U}. Default is NULL and \code{alpha2} is initialized based
#' on update rules derived in Durif et al. (2017). This input parameter is
#' not used if the input parameter \code{U} is not NULL. Note: in the
#' standard GaP factor model, all row of \code{alpha2} should be identical.
#' @param beta1 matrix of dimension \code{p x K}, initial values for the
#' prior shape parameter of the Gamma variational distribution over the
#' factor \code{V}. Default is NULL and \code{beta1} is initialized based
#' on update rules derived in Durif et al. (2017). This input parameter is
#' not used if the input parameter \code{U} is not NULL. Note: in the
#' standard GaP factor model, all row of \code{beta1} should be identical.
#' @param beta2 matrix of dimension \code{p x K}, initial values for the
#' prior rate parameter of the Gamma variational distribution over the
#' factor \code{V}. Default is NULL and \code{beta2} is initialized based
#' on update rules derived in Durif et al. (2017). This input parameter is
#' not used if the input parameter \code{U} is not NULL. Note: in the
#' standard GaP factor model, all row of \code{beta2} should be identical.
#' @param prob_S matrix of dimension \code{p x K}, initial values for the
#' variational probability parameter for the sparsity indicator matrix \code{S}
#' over the factor \code{V}. Default is NULL and \code{prob_S} is initialized
#' randomly.
#' @param prior_S vector of length \code{p}, initial values for the
#' prior probability parameter for the sparsity indicator matrix \code{S} over
#' the factor \code{V}. Default is NULL and \code{prior_S} is initialized
#' randomly.
#' @param prob_D matrix of dimension \code{n x p}, initial values for the
#' variational probability parameter for the drop-out indicator matrix \code{D}
#' accounting for zero-inflation in \code{X}. Default is NULL
#' and \code{prob_D} is initialized by the frequence of zero in the
#' corresponding column of \code{X}. This parameter is not used for model
#' without zero-inflation.
#' @param prior_D vector of length \code{p}, initial values for the
#' prior probability parameter for the drop-out indicator matrix \code{D}
#' accounting for zero-inflation in \code{X}. Default is NULL and
#' \code{prior_D} is initialized by the frequence of zero in the
#' corresponding column of \code{X}. This parameter is not used for model
#' without zero-inflation.
#'
#' Note: input parameters \code{a1}, \code{a2}, \code{b1}, \code{b2} should
#' all be set to be used. Similarly, \code{alpha1}, \code{alpha2},
#' \code{beta1}, \code{beta2} should all be set to be used.
#'
#' @import Rcpp
#' @import RcppEigen
#' @importFrom Rcpp evalCpp
#' @useDynLib pCMF, .registration = TRUE
#'
#' @return list of Poisson NMF output
#' \item{factor}{list of estimated factor matrices:
#'     \code{U}: matrix of dimension \code{n x K}, representation of
#'     individuals in the subspace of dimension \code{K}.
#'     \code{V}: matrix of dimension \code{p x K}, contributions of variables
#'     to the subspace of dimension \code{K}.}
#' \item{convergence}{list of items related to the algorithm convergence:
#'     \code{converged}: boolean indicating if convergence was reached.
#'     \code{nb_iter}: integer, number of effective iterations.
#'     \code{conv_mode}: input \code{conv_mode} parameter.
#'     \code{conv_crit}: vector of size \code{nb_iter}, values of the
#'     convergence criterion across iterations.}
#' \item{loss}{double, values of the loss after iterations.}
#' \item{monitor}{list of monitored criteria if \code{conv_mode} input
#' parameter was set to 1, not returned otherwise:
#'     \code{norm_gap}: vector of size \code{nb_iter}, values of normalized
#'     gap between iterates across iterations.
#'     \code{abs_gap}: vector of size \code{nb_iter}, values of absolute
#'     gap between iterates across iterations.
#'     \code{loglikelihood}: vector of size \code{nb_iter}, values of the
#'     log-likelihood associated to the Poisson NMF model across iterations.
#'     \code{deviance}: vector of size \code{nb_iter}, values of the
#'     deviance associated to the Poisson NMF model across iterations.
#'     \code{optim_criterion}: vector of size \code{nb_iter}, values of the
#'     loss across iterations.}
#' \item{variational_params}{list of estimated value for variational
#' parameters:
#'     \code{a1} and \code{a2}: matrix of dimension \code{n x K}.
#'     \code{b1} and \code{b2}: matrix of dimension \code{p x K}.}
#' \item{hyper_params}{list of estimated value for hyper parameters:
#'     \code{alpha1} and \code{alpha2}: matrix of dimension \code{n x K}.
#'     \code{beta1} and \code{beta2}: matrix of dimension \code{p x K}.}
#' \item{stats}{list of exhaustive statistics relaed to the variational
#' distribution:
#'     \code{EU}: expectation of U, matrix of dimension \code{n x K}.
#'     \code{ElogU}: expectation of log U, matrix of dimension \code{n x K}.
#'     \code{EV}: expectation of V, matrix of dimension \code{p x K}.
#'     \code{ElogV}: expectation of log V, matrix of dimension \code{p x K}.}
#' \item{sparse_param}{list of estimated values for variational and hyper
#' parameters regarding sparsity in \code{V} (see Durif et al. (2017) for
#' more details):
#'     \code{prob_S}: matrix of size \code{p x K}, variational probabilities
#'     for each entry \eqn{V_{jk}} to be non-null.
#'     \code{prior_prob_S}: vector of size \code{p}, estimated prior
#'     probability for each variable/gene to contribute in \code{V}.
#'     \code{S}: matrix of size \code{p x K}, matrix of indicators \eqn{S_{jk}}
#'     correspondings to null (if 0) and non-null (if 1) entries \eqn{V_{jk}}
#'     according to variational distribution.}
#' \item{seed}{positive integer value corresponding to the value given as
#' seed in input parameter for random number generation.}
#'
#' @examples
#' \dontrun{
#' ## generate data
#' n <- 100
#' p <- 200
#' K <- 10
#' factorU <- generate_factor_matrix(n, K, ngroup=3, average_signal=60,
#'                                   group_separation=0.8,
#'                                   distribution="gamma",
#'                                   shuffle_feature=TRUE)
#' factorV <- generate_factor_matrix(p, K, ngroup=2, average_signal=60,
#'                                   group_separation=0.8,
#'                                   distribution="gamma",
#'                                   shuffle_feature=TRUE,
#'                                   prop_noise_feature=0.4)
#' U <- factorU$factor_matrix
#' V <- factorV$factor_matrix
#' count_data <- generate_count_matrix(n, p, K, U, V,
#'                                     ZI=TRUE, prob1=rep(0.3,p))
#' X <- count_data$X
#' ## or use your own data as a count matrix
#' ## of dimension cells x genes (individuals x features)
#' ## run matrix factorization algorithm
#' res <- run_zi_sparse_gap_factor(X, K, verbose=FALSE)
#' }
#'
#' @export
run_zi_sparse_gap_factor <- function(X, K, sel_bound = 0.5, U = NULL, V = NULL, verbose = TRUE, monitor = TRUE, iter_max = 1000L, iter_min = 500L, init_mode = "random", epsilon = 1e-2, additional_iter = 10L, conv_mode = 1L, ninit = 1L, iter_init = 100L, ncores = 1L, reorder_factor = TRUE, seed = NULL, a1 = NULL, a2 = NULL, b1 = NULL, b2 = NULL, alpha1 = NULL, alpha2 = NULL, beta1 = NULL, beta2 = NULL, prob_S = NULL, prior_S = NULL, prob_D = NULL, prior_D = NULL) {
    .Call(`_pCMF_run_zi_sparse_gap_factor`, X, K, sel_bound, U, V, verbose, monitor, iter_max, iter_min, init_mode, epsilon, additional_iter, conv_mode, ninit, iter_init, ncores, reorder_factor, seed, a1, a2, b1, b2, alpha1, alpha2, beta1, beta2, prob_S, prior_S, prob_D, prior_D)
}

