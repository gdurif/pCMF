% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils.R
\name{getV}
\alias{getV}
\title{getV}
\usage{
getV(model, log_representation = TRUE)
}
\arguments{
\item{model}{a Gamma-Poisson factor model output by the
function \code{\link{pCMF}} or a Poisson NMF model output by the
function \code{\link{run_poisson_nmf}}}

\item{log_representation}{boolean, useful only with the Gamma Poisson
factor model, it indicates if the representation is in
the natural geometry associated to the Gamma distribution (log) or in the
Euclidean space, default is TRUE}
}
\value{
the matrix \code{V} of individual coordinates in the lower
dimensional sub-space (or \code{log V} if requested)
}
\description{
Getter for the matrix V in the pCMF/NMF framework (\eqn{X ~ UV^t})
}
\details{
We consider a count data matrix \eqn{X} with
\eqn{n} observations/individuals in rows and
\eqn{p} recorded variables in columns.

In the matrix factorization framework (Poisson NMF or Gamma-Poisson
factor model), the data matrix \eqn{X_{n\times p}} is approximated by the
product \eqn{UV^t} where \eqn{U_{n \times K}} and \eqn{V_{p\times K}}
are respectively the observation coordinates and variable loadings in
the latent space of lower dimension \eqn{K}.

This function returns the matrix \code{V}.

In the case of the Gamma-Poisson factor model, the geometry related to the
Gamma distribution in the exponential family is a log-representation,
thus, if requested, the matrix \code{log V} can be returned.
}
\examples{
\dontrun{
## generate data
n <- 100
p <- 200
K <- 10
factorU <- generate_factor_matrix(n, K, ngroup=3, average_signal=60,
                                  group_separation=0.8,
                                  distribution="gamma",
                                  shuffle_feature=TRUE)
factorV <- generate_factor_matrix(p, K, ngroup=2, average_signal=60,
                                  group_separation=0.8,
                                  distribution="gamma",
                                  shuffle_feature=TRUE)
U <- factorU$factor_matrix
V <- factorV$factor_matrix
count_data <- generate_count_matrix(n, p, K, U, V)
X <- count_data$X
## or use your own data as a count matrix
## of dimension cells x genes (individuals x features)
## run pCMF algorithm
res <- pCMF(X, K, verbose=FALSE)
## get U and V
hatU <- getU(res)
hatV <- getV(res)
}

}
\seealso{
\code{\link{pCMF}}, \code{\link{run_poisson_nmf}}
}
\author{
Ghislain Durif, \email{gd.dev@libertymail.net}
}
